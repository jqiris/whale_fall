use crate::tpls::engine::render_template;
use anyhow::Result;
use serde::{Deserialize, Serialize};
pub const HTTP_ROUTE_TPL: &str = r#"// Code generated by whale_fall. DO NOT EDIT.
package route

import (
	"time"

	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/otel/attribute"

	"{{project}}/common"
	"{{project}}/common/core/log"
	"{{project}}/common/core/otel/prometheus"
	"{{project}}/common/core/otel/tracing"


	"{{entry_pkg_path}}/handler"
	"{{entry_pkg_path}}/middleware"
	"{{entry_pkg_path}}/types"
)

func generated(r gin.IRoutes) {

	{{#each groups}}
	// ----------------------------------- {{group_name}} -----------------------------------
	{{#each fun_list}}
	// {{fun_mark}}
	r.POST("{{uri}}",{{#each this.middlewares}}middleware.{{this}}{{/each}}, func(ctx *gin.Context) {
		var (
			st = time.Now()
			_ctx = common.HTTPMetadata(ctx)
			req = &types.{{this.req_name}}{}
			resp = &types.{{this.resp_name}}{}
			err error
		)
		reqRaw,raw,_common, err := reqJSON(ctx)
		if err != nil {
			JSONError(ctx, common.ErrParams)
			return
		}
		if _common != nil {
			_ctx = context.WithValue(_ctx,common.IOCommonParamsKey,_common)
		}
		_ctx, span := tracing.StartSpan(_ctx, "http:{{this.uri}}")
		defer func() {
			span.End()
			prometheus.HistogramVec.Timing("http_seconds", map[string]string{
				"entry":  "{{../entry_name}}",
				"api":    "{{this.uri}}",
				"ret":    prometheus.RetLabel(err),
			}, st)
			_resp,_ := tools.JSON.Marshal(resp)
			log.With().TraceID(_ctx).Field("common",_common).Field("uri", "{{this.uri}}").Field("req", raw).Field("resp", _resp).Field("err", err).Info("on-http")
		}()
		if err = common.BindBody(reqRaw, &req); err != nil {
			JSONError(ctx, common.ErrParams)
			return
		}
		resp, err = handler.{{fun_name}}(_ctx, req)
		JSON(ctx, resp, err)
	})
	{{/each}}
	{{/each}}
}
"#;
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct HttpEntry {
    pub project: String,
    pub app_name: String,
    pub app_name_uf: String,
    pub app_pkg_path: String,
    pub entry_name: String,
    pub entry_path: String,
    pub entry_pkg_path: String,
    pub socket_type: String,
    pub socket_type_uf: String,
    pub groups: Vec<EntryGroup>,
}
#[derive(Debug, Serialize, Deserialize, Default, Clone)]
pub struct EntryGroup {
    pub group: String,
    pub group_ufirst: String,
    pub group_name: String,
    pub gmiddlewares: Vec<String>,
    pub fun_list: Vec<EntryFunItem>,
}
#[derive(Debug, Serialize, Deserialize, Default, Clone)]
pub struct EntryFunItem {
    pub fun_name: String,
    pub method: String,
    pub fun_mark: String,
    pub req_name: String,
    pub resp_name: String,
    pub middlewares: Vec<String>,
    pub uri: String,
    pub uri2: String,
}

impl HttpEntry {
    pub fn execute(&self, tpl: &str) -> Result<String> {
        render_template(tpl, self)
    }
}
