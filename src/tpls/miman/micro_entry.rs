use crate::tpls::engine::render_template;
use anyhow::Result;
use serde::{Deserialize, Serialize};
pub const MICRO_ENTRY_TPL: &str = r#"// Code generated by whale_fall. DO NOT EDIT.
package provider

import (
	"context"

	"{{app_pkg_path}}/types_{{app_name}}"
	
)

type {{app_name_uf}}Interface interface {
	{{#each fun_list}}
		// {{fun_name}} {{fun_mark}} 
		{{fun_name}}(ctx context.Context, input *types_{{../app_name}}.{{req_name}}) (*types_{{../app_name}}.{{resp_name}},error)
	{{/each}}
}

// Register{{app_name_uf}}
func Register{{app_name_uf}}({{app_name}} {{app_name_uf}}Interface) {
	{{app_name_uf}} = {{app_name}}
}
"#;

pub const MICRO_SERVICE_TPL: &str = r#"// Code generated by whale_fall. DO NOT EDIT.
package {{app_name}}

import (
	"context"
	"time"

	"{{project}}/common"
	"{{project}}/common/core/log"
	"{{project}}/common/core/otel/prometheus"
	"{{project}}/common/core/otel/tracing"

	"{{app_pkg_path}}/types_{{app_name}}"
	"{{app_pkg_path}}/service"
	
)

type {{app_name_uf}} struct {
}

func New{{app_name_uf}}() *{{app_name_uf}} {
	return &{{app_name_uf}}{}
}

{{#each fun_list}}

// {{fun_name}} {{fun_mark}} 
func (s *{{../app_name_uf}}){{fun_name}}(ctx context.Context, input *types_{{../app_name}}.{{req_name}}) (*types_{{../app_name}}.{{resp_name}},error) {
	var (
		st = time.Now()
		resp = &types_{{../app_name}}.{{resp_name}}{}
		err error
	)
	ctx, span := tracing.StartSpan(ctx, "micro:{{../app_name}}_{{fun_name}}")
	defer func() {
		span.End()
		prometheus.HistogramVec.Timing("micro_seconds", map[string]string{
			"micro":  "{{../app_name}}",
			"func":   "{{fun_name}}",
			"ret":    prometheus.RetLabel(err),
		}, st)
		//log.With().TraceID(ctx).Field("req", input).Field("resp", resp).Field("err", err).Debug("on-micro")
	}()
	
	resp, err = service.{{service}}Instance().{{method}}(ctx,input)
	return resp, err
}	

{{/each}}
"#;
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct MicroEntry {
    pub project: String,
    pub app_name: String,
    pub app_name_uf: String,
    pub app_pkg_path: String,
    pub fun_list: Vec<MicroFunItem>,
}
#[derive(Debug, Serialize, Deserialize, Default, Clone)]
pub struct MicroFunItem {
    pub service: String,
    pub method: String,
    pub fun_name: String,
    pub fun_mark: String,
    pub req_name: String,
    pub resp_name: String,
}

impl MicroEntry {
    pub fn execute(&self, tpl: &str) -> Result<String> {
        render_template(tpl, self)
    }
}
